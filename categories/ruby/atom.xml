<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | jamesconroyfinn.com]]></title>
  <link href="http://jamesconroyfinn.com/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jamesconroyfinn.com/"/>
  <updated>2012-04-08T23:21:42+01:00</updated>
  <id>http://jamesconroyfinn.com/</id>
  <author>
    <name><![CDATA[James Conroy-Finn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Refactoring in Ruby]]></title>
    <link href="http://jamesconroyfinn.com/2010/10/refactoring-in-ruby/"/>
    <updated>2010-10-05T20:11:00+01:00</updated>
    <id>http://jamesconroyfinn.com/2010/10/refactoring-in-ruby</id>
    <content type="html"><![CDATA[<p>After reading <a href="http://www.amazon.co.uk/gp/product/0321603508?ie=UTF8&amp;tag=jameconrfinn-21&amp;linkCode=as2&amp;camp=1634&amp;creative=19450&amp;creativeASIN=0321603508">Refactoring: Ruby Edition</a> by <a href="http://blog.jayfields.com/">Jay Fields</a> a colleague reminded of a very old open Q&amp;A session at the end of a <a href="http://video.google.com/videoplay?docid=1149552518153462279#">Snakes and Rubies</a> event with the creator of Rails, <a href="http://loudthinking.com)">David Heinemeier Hansson</a>, and the co-creator of the Django framework, <a href="http://www.holovaty.com/">Adrian Holovaty</a>.</p>

<p>After some debate it was agreed that a significant difference between Ruby and Python is that in Python there is one way to do something, in Ruby there are many. David made a valid point however when he argues that of all the ways of doing something in Ruby there is generally one that feels right, an implementation that is more beautiful and that's where <a href="http://www.amazon.co.uk/gp/product/0321603508?ie=UTF8&amp;tag=jameconrfinn-21&amp;linkCode=as2&amp;camp=1634&amp;creative=19450&amp;creativeASIN=0321603508">Refactoring: Ruby Edition</a> proves to be an excellent read.</p>

<p>Refactoring code isn't something most programmers enjoy but it is something I like to do when the time is right.</p>

<!--more-->


<h2>When to Refactor</h2>

<p>It's not practical or pragmatic spending all of your time refactoring code, but there are occasions where it makes sense to remove some code smell and make the process of changing or extending business logic easier.</p>

<p>Jay Fields quotes a guideline <a href="http://www.refactory.com/people/don.html">Don Roberts</a> gave him. "The Rule of Three" states the first time you do something you just do it. The second time you do something similar you wince at the duplication. The third time you refactor.</p>

<h3>Refactor When Adding New Functionality</h3>

<p>Whether it's to simply understand something you or someone else has written in the past it can be helpful to understand some complicated code and refactor it to make it simpler and more easily understood.</p>

<h3>Refactor When You Need to Fix a Bug</h3>

<p>When it's time to fix something that doesn't work it can be a good time to consider simplification through refactoring, although not always!</p>

<h3>Refactoring During Code Reviews</h3>

<p>I'm a big fan of code reviews and genuinely appreciate constructive criticism from colleagues. Sharing knowledge and experience only improves a team and is a logical time to consider refactoring.</p>

<h2>Time to Refactor</h2>

<p>Consider a babe. There might be many babes but all babes have some attributes your boss is interested in. As a programmer our boss wants us to work out how babes work and makes sure our application can predict their behaviour in order to make lots and lots of money.</p>

<p>So someone creates a babe based solely upon what they know about babes. It turns out they don't know that much but everyone in the team pools knowledge and eventually after several interactions we know enough about babes to keep the board of directors happy.</p>

<p><div><script src='https://gist.github.com/965202.js?file='></script>
<noscript><pre><code>class Babe
  def initialize(name, hair_color, weight, hotness, nationality)
    @name = name
    @hair_color = hair_color
    @weight = weight
    @hotness = hotness
    @nationality = nationality
  end

  def dance
    if nationality == 'American'
      return 'Grind'
    elsif nationality == 'British'
      return 'Wiggle'
    elsif type == 'German'
      return 'Strut'
    else
      return 'Bounce'
    end
  end

  def speak
    if nationality == 'American'
      return 'Totally'
    elsif nationality == 'British'
      return 'Woteva'
    elsif type == 'German'
      return 'Ja'
    else
      return 'Hi'
    end
  end

  def fit?
    @weight &lt; 100
  end

  def beautiful?
    @hotness &gt; 2
  end

  def in_my_league?
    if fit?
      if beautiful?
        return false
      else
        return true
      end
    end
    false
  end
end</code></pre></noscript></div>
</p>

<p>Now we're doing a code review and looking at how a babe works. There's some repetition in the <code>#dance</code> and <code>#speak</code> methods and the <code>#in_my_league?</code> method
has grown in to something quite difficult to understand.</p>

<p>We're working with Ruby, which means we can do almost anything we want to a babe but let's remember what DHH said, there's always a beautiful way to do something
and that's what we want. Beautiful babes.</p>

<h2>Initialisation</h2>

<p>Let's start with the <code>#initialize</code> method. It takes a whole lot of arguments, in a very specific order, which makes it quite difficult to work with.</p>

<p><div><script src='https://gist.github.com/965216.js?file='></script>
<noscript><pre><code>def initialize(name, attributes = {})
  @name = name
  attributes.each do |attribute, value|
    instance_variable_set(&quot;@#{attribute}&quot;, value)
  end
end</code></pre></noscript></div>
</p>

<p>Using a hash of optional attributes gives us named arguments. Much nicer when creating a new babe but not ideal when you don't aren't sure which attributes in a babe matter to the boss!</p>

<p>So we could define valid attributes and only extract those using <code>#slice</code>.</p>

<p><div><script src='https://gist.github.com/965218.js?file='></script>
<noscript><pre><code>VALID_ATTRIBUTES = [:hair_color, :weight, :hotness, :nationality]

def initialize(name, attributes = {})
  @name = name
  extract_attributes(attributes)
end

private

def extract_attributes(attributes)
  attributes.slice(*VALID_ATTRIBUTES).each do |name, value|
    instance_variable_set(&quot;@#{name}&quot;, value)
  end
end</code></pre></noscript></div>
</p>

<p>Better but not beautiful, yet. Named arguments are great but not validating them doesn't feel right in my opinion.</p>

<p>A number of methods in Rails use <code>#assert_valid_keys</code> to ensure only valid options are passed to a method and we can do the same.</p>

<p><div><script src='https://gist.github.com/965227.js?file='></script>
<noscript><pre><code>require 'active_support/core_ext/hash'

class Babe
  VALID_ATTRIBUTES = [:hair_color, :weight, :hotness, :nationality]

  attr_accessor *VALID_ATTRIBUTES

  def initialize(name, attributes = {})
    @name = name
    attributes.assert_valid_keys(*VALID_ATTRIBUTES)
    @hair_color  = attributes[:hair_color]
    @weight      = attributes[:weight]
    @hotness     = attributes[:hotness]
    @nationality = attributes[:nationality]
  end

  # ...
end</code></pre></noscript></div>
</p>

<h3>Bad Metamonkey!</h3>

<p>Refactoring does not mean "show me your Ruby foo!" Temptation to add crazy methods like I do below is often best resisted.</p>

<p><div><script src='https://gist.github.com/965229.js?file='></script>
<noscript><pre><code>require 'active_support/core_ext/hash'

class Object
  def attr_accessors_from_hash(hash)
    hash.each do |name, value|
      self.class.send(:attr_accessor, name)
      self.send(&quot;#{name}=&quot;, value)
    end
  end
end

class Babe
  VALID_ATTRIBUTES = [:hair_color, :weight, :hotness, :nationality]

  def initialize(name, attributes = {})
    @name = name
    attributes.assert_valid_keys(*VALID_ATTRIBUTES)
    attr_accessors_from_hash(attributes)
  end

  # ...
end</code></pre></noscript></div>
</p>

<p>Why you might ask? Because <code>attr_accessors_from_hash</code> isn't part of Ruby. The method name is relatively self-explanatory but once you find the implementation consider this. What the hell does that method do? I'd argue it's not very readable and to be honest quite unnecessary.</p>

<h2>Dancing &amp; Speaking</h2>

<p>The board of directors made it very clear that in their opinion two of the most important things each and everyone of our babes do is dance and speak. Both are entirely dependent on the same factors, nationality. According to the directors.</p>

<p><div><script src='https://gist.github.com/965235.js?file='></script>
<noscript><pre><code>class Babe
  SKILLS = {
    'American' =&gt; %w(Grind Totally),
    'British' =&gt; %w(Wiggle Woteva),
    'German' =&gt; %w(Strut Ja),
  }
  SKILLS.default = %w(Bounce Hi)

  # ...

  def dance
    SKILLS[nationality].first
  end

  def speak
    SKILLS[nationality].last
  end

  # ...
end</code></pre></noscript></div>
</p>

<h2>New improved babes</h2>

<p>With a <code>Nationality</code> class we can extract the nationality behaviour out of <code>Babe</code> and delegate what a babe's likely to say or how she's going to dance to her nationality improving code quality and perpetuating confusing stereotypes.</p>

<p><div><script src='https://gist.github.com/965239.js?file='></script>
<noscript><pre><code>require 'active_support/core_ext/hash'

class Nationality &lt; Struct.new(:name, :dance_move, :speech)
  class &lt;&lt; self
    def all
      @nationalities ||= [
        Nationality.new('American', 'Grind', 'Totally'),
        Nationality.new('British', 'Wiggle', 'Woteva'),
        Nationality.new('German', 'Strut', 'Ja'),
      ]
    end

    def default
      @default ||= Nationality.new('Unknown', 'Bounce', 'Hi')
    end

    def find(place)
      all.detect { |nationality| nationality.name == place }
    end
  end

  alias :dance :dance_move
  alias :speak :speech
end

class Babe
  extend Forwardable

  VALID_ATTRIBUTES = [:hair_color, :weight, :hotness, :nationality]

  def_delegators :nationality, :dance, :speak
  attr_accessor *VALID_ATTRIBUTES

  def initialize(name, weight, hotness, attributes = {})
    attributes.assert_valid_keys(*VALID_ATTRIBUTES)

    self.name        = name
    self.hair_color  = attributes[:hair_color]
    self.weight      = attributes[:weight]
    self.hotness     = attributes[:hotness]
    self.nationality = attributes[:nationality]
  end

  def nationality
    @nationality || Nationality.default
  end

  def nationality=(place)
    @nationality = Nationality.find(place)
  end

  def fit?
    weight.try(:&lt;, 100)
  end

  def beautiful?
    hotness.try(:&gt;, 2)
  end

  def in_my_league?
    fit? ^ beautiful?
  end
end</code></pre></noscript></div>
</p>

<p>So that's it. Refactored and all round an improvement I think.</p>
]]></content>
  </entry>
  
</feed>
