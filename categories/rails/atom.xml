<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | jamesconroyfinn.com]]></title>
  <link href="http://jamesconroyfinn.com/categories/rails/atom.xml" rel="self"/>
  <link href="http://jamesconroyfinn.com/"/>
  <updated>2012-04-08T23:21:42+01:00</updated>
  <id>http://jamesconroyfinn.com/</id>
  <author>
    <name><![CDATA[James Conroy-Finn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spoofing Remote Addresses in Tests]]></title>
    <link href="http://jamesconroyfinn.com/2012/03/spoofing-remote-addresses-in-tests/"/>
    <updated>2012-03-30T15:28:00+01:00</updated>
    <id>http://jamesconroyfinn.com/2012/03/spoofing-remote-addresses-in-tests</id>
    <content type="html"><![CDATA[<p>In the process of testing some custom error handling I found myself
needing to fake my remote address when visiting pages with Capybara and
Rack::Test.</p>

<p>To do this I had to delve in to the internals of Rack::Test using the
following Cucumber step.</p>

<p>``` ruby
Given /<sup>I</sup> send requests from a remote address$/ do
  page.driver.browser.current_session.instance_eval {</p>

<pre><code>@headers['REMOTE_ADDR'] = '10.0.1.1'
</code></pre>

<p>  }
end
```</p>

<p>The reason this is necessary is that Rack::Test does not expose
the <code>REMOTE_ADDR</code> header, instead always setting the value to 127.0.0.1.</p>

<!-- more -->


<p>``` ruby
def default_env
  { "rack.test" => true, "REMOTE_ADDR" => "127.0.0.1" }.merge(headers_for_env)
end</p>

<p>def headers_for_env
  converted_headers = {}</p>

<p>  @headers.each do |name, value|</p>

<pre><code>env_key = name.upcase.gsub("-", "_")
env_key = "HTTP_" + env_key unless "CONTENT_TYPE" == env_key
converted_headers[env_key] = value
</code></pre>

<p>  end</p>

<p>  converted_headers
end
```</p>

<ul>
<li><a href="https://github.com/rails/rails/issues/671#issuecomment-1780159">404s in Rails 3</a></li>
<li><a href="http://www.alexrothenberg.com/2011/11/21/testing-ip-whitelisting-in-your-specs-and-features.html">Alex Rothenberg</a></li>
<li><a href="https://github.com/brynary/rack-test/blob/fa7c6f9baf06e13352b42887e96c15c69bc10cb2/lib/rack/test.rb#L271">Rack::Test#default_env</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Please do REST right]]></title>
    <link href="http://jamesconroyfinn.com/2011/05/please-do-rest-right/"/>
    <updated>2011-05-02T20:11:00+01:00</updated>
    <id>http://jamesconroyfinn.com/2011/05/please-do-rest-right</id>
    <content type="html"><![CDATA[<p>I recently received an email from a large email delivery company bragging about a great new RESTful API, which got me quite excited because their current offering is pretty poor.</p>

<!--more-->


<p>When I read the following though I became a little concerned:</p>

<p><blockquote><p>Our new RESTful API mediates XML to REST and JSON formats for easier adoption and integration.</p></blockquote></p>

<p>That sentence doesn't read very well to the point of almost being completely nonsensical.</p>

<p>A RESTful API should use HTTP methods to interact with resources. When I want to know about all users I should <code>GET /users</code>, when I want to know about one user I should <code>GET /users/some-unique-identifier</code>, when I want to create a user I should <code>POST</code> to <code>/users</code>. Mixing up these methods or verbs and adding superfluous path parameters is not an example of a good RESTful API.</p>

<p>If you want to do it a different way that's fine. Just don't call it RESTful if it's not.</p>

<p><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services">Representational State Transfer on Wikipedia</a></p>
]]></content>
  </entry>
  
</feed>
